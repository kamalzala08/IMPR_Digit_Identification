# -*- coding: utf-8 -*-
"""digit2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aPgVr4rHu1sICqK2WCr0zk6l1k_tOKuz
"""

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as plt
# %matplotlib inline
import numpy as np

## it will load train and test dataset
(x_train,y_train),(x_test,y_test) = keras.datasets.mnist.load_data()
## x  --> image
## y  --> output
# plt.matshow(x_train[0]) --> to see dataset image

x_train = x_train/255
x_test = x_test/255

x_train_flattened = x_train.reshape(len(x_train),28*28)
x_test_flattened = x_test.reshape(len(x_test),28*28)

## 
model = keras.Sequential([
  
                    # output  input
    keras.layers.Dense(100,input_shape=(784,),activation='relu'),
    keras.layers.Dense(10,activation='sigmoid')
])

model.compile(
    optimizer = 'adam',
    loss = 'sparse_categorical_crossentropy',
    metrics=['accuracy']
)

model.fit(x_train_flattened,y_train,epochs=10)
model.save('digitmodel.h5')

## Now Testing of test dataset
model.evaluate(x_test_flattened,y_test)

## sample predict
for i in range(20):
  plt.matshow(x_train[i])
all_predicted = model.predict(x_test_flattened)

# print(np.argmax(all_predicted[0]))

y_predicted_labels = [np.argmax(i) for i in all_predicted ]
cm = tf.math.confusion_matrix(labels=y_test,predictions=y_predicted_labels)

import seaborn as sn
plt.figure(figsize=(10,7))
sn.heatmap(cm,annot=True,fmt='d')
plt.xlabel('predicted')
plt.ylabel('Truth')

import tensorflow as tf
import cv2
import numpy as np
import matplotlib.pyplot as plt

BASE_DIR = "/content/drive/MyDrive/IMPR PROJECT/Digit Classification/Images/"
# Load the saved model
model = tf.keras.models.load_model('digitmodel.h5')

# Prompt the user for an image path
image_path = input("Enter path to image: ")

image_path = BASE_DIR + image_path

print(f"Image full path : {image_path}")
# Load the image, resize it, and convert it to grayscale
img = cv2.imread(image_path)
img = cv2.resize(img, (28, 28))
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Flatten the grayscale image and normalize it
gray_flattened = gray.reshape(1, 28*28) / 255.0

# Make the prediction
prediction = model.predict(gray_flattened)

# Get the predicted digit and print it
predicted_digit = np.argmax(prediction)

print("\n++++++++++++++++++++++++++++++++++++\n")
print(f"Predicted digit: {predicted_digit}")
print(f"Probability : {np.max(prediction)}")

print("Input Image : \n")

plt.matshow(img)
